#define SC_INCLUDE_DYNAMIC_PROCESSES

#include <systemc.h>
#include "tlm.h"
#include "tlm_utils/simple_initiator_socket.h"
#include "tlm_utils/simple_target_socket.h"

using namespace sc_core;
using namespace sc_dt;
using namespace std;

SC_MODULE(Top){
    Software* software;
    Hardware_System* hardware;
    
    SC_CTOR(Top){
        software = new Software("software");
        hardware = new Hardware_System("hardware");
        
        software->initiator_socket.bind(hardware->target_socket);
    }
};

SC_MODULE(Hardware_System) {

    tlm_utils::simple_target_socket<Hardware_System> target_socket;
    
    SC_CTOR(Hardware_System) : target_socket("target_socket") {
        target_socket.register_b_transport(this, &Hardware_System::b_transport);
    }
    
    virtual void b_transport( tlm::tlm_generic_payload& trans, sc_time& delay);
    int addition(int x, int y);
    int subtraction(int x, int y);
    int equality(int x, int y);
    int remainder(int x, int y);
};

void Hardware_System::b_transport( tlm::tlm_generic_payload& trans, sc_time& delay){
    string cmd = trans.get_command();
    sc_dt::uint64 adr = trans.get_address();
    unsigned int* ptr = trans.get_data_ptr();
    unsigned int len = trans.get_data_length();
    unsigned char* byt = trans.get_byte_enable_ptr();
    unsigned int wid = trans.get_streaming_width();
    
    if(addr >= sc_dt::uint64(SIZE) || byt!=0 || len>4 || wid<len){
        SC_REPORT_ERROR("TLM-2", "Target does not support given generic payload transaction");
    }
    
    int* terms;
    memcpy(&terms, ptr, len);

    int x = terms[1]
    int y = terms[2] 
    int result = -1;
    
    if (cmd == "add"){result = addition(x, y);}
    else if(cmd == "sub"){result = subtraction(x,y);}
    else if(cmd == "eq"){result = equality(x,y);}
    else if(cmd == "rem"){result = remainder(x,y);}
    
    ptr[0]= result; 
    trans.set_response_status(tlm::TLM_OK_RESPONSE); 
}

int Hardware_System::addition(int x, int y){
    int z = x + y;
    wait(10, SC_NS); 
    return z;
}

int Hardware_System::subtraction(int x, int y){
    int z = x - y;
    wait(11, SC_NS);
    return z;
}

int Hardware_System::equality(int x, int y){
    wait(5, SC_NS); 
    return (x == y) ? 1 : 0;
}

int Hardware_System::remainder(int x, int y){
    int z = x % y;
    wait(15, SC_NS);
    return z;
}


SC_MODULE(Software) {
    
    tlm_utils::simple_initiator_socket<Software> initiator_socket;

    SC_CTOR(Software) : initiator_socket("initiator_socket") {
        SC_THREAD(process_commands); 
    }

    void process_commands() {
        sc_time delay = SC_ZERO_TIME;

        int data[3]; 

        send_command("add", 4, 36, delay);
        send_command("eq", 49, 55, delay);
        send_command("rem", 20, 2, delay);
        send_command("sub", 9, 12, delay);
        send_command("add", 12, 1000, delay);
        send_command("rem", 5, 8, delay);
        send_command("rem", 100, 7, delay);
        send_command("sub", 125, 25, delay);
        send_command("eq", 47, 47, delay);
        send_command("add", 5, 6, delay);

        std::cout << "Total simulation time: " << delay << std::endl;
    }

    void send_command(std::string cmd, int x, int y, sc_time &delay) {
        tlm::tlm_generic_payload trans;
        int data[3] = {0, x, y}; 

        trans.set_data_ptr(reinterpret_cast<unsigned char*>(data)); 
        initiator_socket->b_transport(trans, delay); 
        std::cout << "Command: " << cmd << ", Result: " << data[0] << std::endl;
    }
};


int sc_main(int sc_argc, char* sc_argv[]){
    Top top("top"); 
    sc_start(); 
    return 0;
}
